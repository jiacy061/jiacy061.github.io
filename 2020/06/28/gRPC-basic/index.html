<!DOCTYPE html>


  <html lang="zh-CN" class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>gRPC源码分析 | Jiacy | 影子</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="RPC,gRPC,Golang," />
  

  <meta name="description" content="1.RPC 入门1.1.RPC 框架原理&amp;emsp;&amp;emsp;RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。 &amp;emsp;&amp;emsp;RPC框架的调用原理图如下所示： 1.2.业界主流的 R">
<meta name="keywords" content="RPC,gRPC,Golang">
<meta property="og:type" content="article">
<meta property="og:title" content="gRPC源码分析">
<meta property="og:url" content="http://jiacyer.com/2020/06/28/gRPC-basic/index.html">
<meta property="og:site_name" content="Jiacy | 影子">
<meta property="og:description" content="1.RPC 入门1.1.RPC 框架原理&amp;emsp;&amp;emsp;RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。 &amp;emsp;&amp;emsp;RPC框架的调用原理图如下所示： 1.2.业界主流的 R">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://jiacyer.com/images/sx/week3/grpc-pic1.png">
<meta property="og:image" content="http://jiacyer.com/images/sx/week3/grpc-pic2.png">
<meta property="og:image" content="http://jiacyer.com/images/sx/week3/protobuf-pic1.png">
<meta property="og:updated_time" content="2020-07-11T05:17:22.575Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gRPC源码分析">
<meta name="twitter:description" content="1.RPC 入门1.1.RPC 框架原理&amp;emsp;&amp;emsp;RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。 &amp;emsp;&amp;emsp;RPC框架的调用原理图如下所示： 1.2.业界主流的 R">
<meta name="twitter:image" content="http://jiacyer.com/images/sx/week3/grpc-pic1.png">

  

  
    <link rel="icon" href="/earth_favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>



  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            文章
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/project/"
            rel="noopener noreferrer"
            target="_self"
            >
            项目
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            链接
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-RPC-入门"><span class="toc-text">1.RPC 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-RPC-框架原理"><span class="toc-text">1.1.RPC 框架原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-业界主流的-RPC-框架"><span class="toc-text">1.2.业界主流的 RPC 框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-gRPC-简介"><span class="toc-text">1.3.gRPC 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-1-gRPC-概览"><span class="toc-text">1.3.1.gRPC 概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-2-gRPC-特点"><span class="toc-text">1.3.2.gRPC 特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-gRPC-服务端创建"><span class="toc-text">2.gRPC 服务端创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-PROTOBUF协议"><span class="toc-text">2.1.PROTOBUF协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-什么是PROTOBUF协议"><span class="toc-text">2.1.1.什么是PROTOBUF协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-PROTOBUF数据编码"><span class="toc-text">2.1.2.PROTOBUF数据编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-PROTOBUF数据协议的优劣势"><span class="toc-text">2.1.3.PROTOBUF数据协议的优劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-参考"><span class="toc-text">2.1.4.参考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-服务端创建业务代码"><span class="toc-text">2.2.服务端创建业务代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-服务端-service-调用流程"><span class="toc-text">2.3.服务端 service 调用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-服务端注册过程"><span class="toc-text">2.4.服务端注册过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-服务端请求处理流程"><span class="toc-text">2.5.服务端请求处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-客户端发送请求流程"><span class="toc-text">2.6.客户端发送请求流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-ClientConn与ClientConnInterface的关系"><span class="toc-text">2.6.1.ClientConn与ClientConnInterface的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-从零开始创建Demo程序"><span class="toc-text">3.从零开始创建Demo程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-编写并编译proto文件"><span class="toc-text">3.1.编写并编译proto文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-编写Server程序"><span class="toc-text">3.2.编写Server程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-编写Client程序"><span class="toc-text">3.3.编写Client程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-直接通过Goland运行"><span class="toc-text">3.4.直接通过Goland运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-Goland执行go-get报SSL-certificate-problem-unable-to-get-local-issuer-certificate错误"><span class="toc-text">3.4.1.Goland执行go get报SSL certificate problem: unable to get local issuer certificate错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-参考"><span class="toc-text">4.参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-结语"><span class="toc-text">5.结语</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-gRPC-basic" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">gRPC源码分析</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2020.06.28</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Jiacy</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </span>



      

      
      <i class="fa fa-eye"></i>
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      

    </div>
  </header>

  <div class="article-content">
    
      <h1 id="1-RPC-入门"><a href="#1-RPC-入门" class="headerlink" title="1.RPC 入门"></a>1.RPC 入门</h1><h2 id="1-1-RPC-框架原理"><a href="#1-1-RPC-框架原理" class="headerlink" title="1.1.RPC 框架原理"></a>1.1.RPC 框架原理</h2><p>&emsp;&emsp;RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。</p>
<p>&emsp;&emsp;RPC框架的调用原理图如下所示：<br><img src="/images/sx/week3/grpc-pic1.png" alt="RPC框架的调用原理图"></p>
<h2 id="1-2-业界主流的-RPC-框架"><a href="#1-2-业界主流的-RPC-框架" class="headerlink" title="1.2.业界主流的 RPC 框架"></a>1.2.业界主流的 RPC 框架</h2><p>&emsp;&emsp;业界主流的 RPC 框架整体上分为三类：</p>
<ul>
<li>支持多语言的 RPC 框架，比较成熟的有 Google 的 <code>gRPC</code>、Apache（Facebook）的 <code>Thrift</code>；</li>
<li>只支持特定语言的 RPC 框架，例如新浪微博的 <code>Motan</code>；</li>
<li>支持服务治理等服务化特性的分布式服务框架，其底层内核仍然是 RPC 框架, 例如阿里的 <code>Dubbo</code>。</li>
</ul>
<p>&emsp;&emsp;随着微服务的发展，基于语言中立性原则构建微服务，逐渐成为一种主流模式，例如对于后端并发处理要求高的微服务，比较适合采用 Go 语言构建，而对于前端的 Web 界面，则更适合 Java 和 JavaScript。<br>因此，基于多语言的 RPC 框架来构建微服务，是一种比较好的技术选择。例如 Netflix，API 服务编排层和后端的微服务之间就采用 gRPC 进行通信。</p>
<h2 id="1-3-gRPC-简介"><a href="#1-3-gRPC-简介" class="headerlink" title="1.3.gRPC 简介"></a>1.3.gRPC 简介</h2><p>&emsp;&emsp;gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端，基于 HTTP/2 设计。</p>
<h2 id="1-3-1-gRPC-概览"><a href="#1-3-1-gRPC-概览" class="headerlink" title="1.3.1.gRPC 概览"></a>1.3.1.gRPC 概览</h2><p>&emsp;&emsp;gRPC 是由 Google 开发并开源的一种语言中立的 RPC 框架，当前支持 C、Java 和 Go 语言，其中 C 版本支持 C、C++、Node.js、C# 等。</p>
<p>&emsp;&emsp;gRPC 的调用示例如下所示：<br><img src="/images/sx/week3/grpc-pic2.png" alt="gRPC的调用示例"></p>
<h2 id="1-3-2-gRPC-特点"><a href="#1-3-2-gRPC-特点" class="headerlink" title="1.3.2.gRPC 特点"></a>1.3.2.gRPC 特点</h2><ul>
<li>语言中立，支持多种语言；</li>
<li>基于 IDL 文件定义服务，通过 <code>proto3</code> 工具生成指定语言的数据结构、服务端接口以及客户端 Stub；</li>
<li>通信协议基于标准的 <code>HTTP/2</code> 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量；</li>
<li>序列化支持 <code>PB（Protocol Buffer）</code> 和 <code>JSON</code>，PB 是一种语言无关的高性能序列化框架，基于 HTTP/2 + PB, 保障了 RPC 调用的高性能。</li>
</ul>
<h1 id="2-gRPC-服务端创建"><a href="#2-gRPC-服务端创建" class="headerlink" title="2.gRPC 服务端创建"></a>2.gRPC 服务端创建</h1><p>&emsp;&emsp;以官方 Go 语言的 helloworld 为例，介绍 gRPC 服务端创建以及 service 调用流程（采用简单 RPC 模式）。流式请求和响应的基本原理类似，下文就不再详细探讨。</p>
<h2 id="2-1-PROTOBUF协议"><a href="#2-1-PROTOBUF协议" class="headerlink" title="2.1.PROTOBUF协议"></a>2.1.PROTOBUF协议</h2><h3 id="2-1-1-什么是PROTOBUF协议"><a href="#2-1-1-什么是PROTOBUF协议" class="headerlink" title="2.1.1.什么是PROTOBUF协议"></a>2.1.1.什么是PROTOBUF协议</h3><p>&emsp;&emsp;protocolbuffer(以下简称PB)是google的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：JAVA、C++、Python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml 进行数据交换快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。</p>
<h3 id="2-1-2-PROTOBUF数据编码"><a href="#2-1-2-PROTOBUF数据编码" class="headerlink" title="2.1.2.PROTOBUF数据编码"></a>2.1.2.PROTOBUF数据编码</h3><p>proto文件定义了协议数据中的实体结构(message, field)</p>
<ul>
<li>关键字<code>message</code>: 代表了实体结构，由多个消息字段<code>field</code>组成；</li>
<li>消息字段<code>field</code>: 包括数据类型、字段名、字段规则、字段唯一标识、默认值；</li>
<li>数据类型：如下图所示；</li>
<li>字段规则：<ul>
<li><code>required</code>：必须初始化字段，如果没有赋值，在数据序列化时会抛出异常；</li>
<li><code>optional</code>：可选字段，可以不必初始化；</li>
<li><code>repeated</code>：数据可以重复(相当于Java 中的Array或List)；</li>
<li>字段唯一标识：序列化和反序列化将会使用到。<br><img src="/images/sx/week3/protobuf-pic1.png" alt="PROTOBUF协议数据类型"></li>
</ul>
</li>
</ul>
<h3 id="2-1-3-PROTOBUF数据协议的优劣势"><a href="#2-1-3-PROTOBUF数据协议的优劣势" class="headerlink" title="2.1.3.PROTOBUF数据协议的优劣势"></a>2.1.3.PROTOBUF数据协议的优劣势</h3><p>优点：</p>
<ul>
<li>二进制消息，性能好/效率高（空间和时间效率都很不错）</li>
<li>平台无关，语言无关，可扩展；</li>
<li>提供了友好的动态库，使用简单；</li>
<li>解析速度快，比对应的XML快约20-100倍；</li>
<li>序列化数据非常简洁、紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10；</li>
<li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级；</li>
<li>支持多种语言（可以把 proto 文件看做 IDL 文件）；</li>
<li>Netty 等一些框架集成。</li>
</ul>
<p>缺点：</p>
<ul>
<li>官方只支持<code>C++</code>，<code>JAVA</code>和<code>Python</code>语言绑定；</li>
<li>二进制可读性差；</li>
<li>二进制不具有自描述特性；</li>
<li>默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）；</li>
<li>只涉及序列化和反序列化技术，不涉及 RPC 功能（类似 XML 或者 JSON 的解析器）。</li>
</ul>
<h3 id="2-1-4-参考"><a href="#2-1-4-参考" class="headerlink" title="2.1.4.参考"></a>2.1.4.参考</h3><p><a href="https://www.jianshu.com/p/bf515a264085" target="_blank" rel="external">详解通信数据协议ProtoBuf</a></p>
<h2 id="2-2-服务端创建业务代码"><a href="#2-2-服务端创建业务代码" class="headerlink" title="2.2.服务端创建业务代码"></a>2.2.服务端创建业务代码</h2><p>&emsp;&emsp;用 <code>Protocol Buffer</code> 服务定义如下（helloworld.proto）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">syntax = &quot;proto3&quot;;</div><div class="line"></div><div class="line">option go_package = &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;;</div><div class="line">option java_multiple_files = true;</div><div class="line">option java_package = &quot;io.grpc.examples.helloworld&quot;;</div><div class="line">option java_outer_classname = &quot;HelloWorldProto&quot;;</div><div class="line"></div><div class="line">package helloworld;</div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter &#123;</div><div class="line">  // Sends a greeting</div><div class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The request message containing the user&apos;s name.</div><div class="line">message HelloRequest &#123;</div><div class="line">  string name = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply &#123;</div><div class="line">  string message = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;服务端创建代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// server 继承 /examples/helloworld/helloworld/helloworld_grpc.pb.go 中的 UnimplementedGreeterServer，获得一个默认的 SayHello 方法实现，即报错提醒。</span></div><div class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</div><div class="line">  pb.UnimplementedGreeterServer</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SayHello 真正的实现</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</div><div class="line">  log.Printf(<span class="string">"Received: %v"</span>, in.GetName())</div><div class="line">  <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">"Hello "</span> + in.GetName()&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="comment">// 监听端口</span></div><div class="line">  lis, err := net.Listen(<span class="string">"tcp"</span>, port)</div><div class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 启动GRPC服务</span></div><div class="line">  s := grpc.NewServer()</div><div class="line">  <span class="comment">// 注册具体服务</span></div><div class="line">  pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</div><div class="line">  <span class="comment">// 绑定GPRC服务到端口上</span></div><div class="line">  <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</div><div class="line">    log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;客户端调用服务代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 建立连接</span></div><div class="line">	conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())</div><div class="line">	...</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line">	c := pb.NewGreeterClient(conn)</div><div class="line"></div><div class="line">	<span class="comment">// 向服务器发送请求，并打印返回的Message</span></div><div class="line">	name := <span class="string">"world"</span></div><div class="line">	...</div><div class="line">	r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)</div><div class="line">	...</div><div class="line">	log.Printf(<span class="string">"Greeting: %s"</span>, r.GetMessage())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-3-服务端-service-调用流程"><a href="#2-3-服务端-service-调用流程" class="headerlink" title="2.3.服务端 service 调用流程"></a>2.3.服务端 service 调用流程</h2><p>&emsp;&emsp;整个 service 调用可以划分为如下四个过程：</p>
<ul>
<li>gRPC 请求消息接入；</li>
<li>gRPC 消息头和消息体处理；</li>
<li>内部的服务路由和调用；</li>
<li>响应消息发送。</li>
</ul>
<h2 id="2-4-服务端注册过程"><a href="#2-4-服务端注册过程" class="headerlink" title="2.4.服务端注册过程"></a>2.4.服务端注册过程</h2><p>&emsp;&emsp;从服务端创建代码中可以看到，其注册服务的核心就是<code>pb.RegisterGreeterServer(s, &amp;server{})</code>函数，该函数位于<code>google.golang.org/grpc/examples/helloworld/helloworld/helloworld_grpc.pb.go</code>文件中，是 <code>protoc-gen-go-grpc</code> 编译生成的代码，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterGreeterServer</span><span class="params">(s *grpc.Server, srv GreeterServer)</span></span> &#123;</div><div class="line">  s.RegisterService(&amp;_Greeter_serviceDesc, srv)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;其核心就是调用<code>grpc.Server</code>的<code>RegisterService</code>方法，参数分别是一个服务描述实例和具体服务实例，描述实例是 <code>protoc</code> 自动生成的，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _Greeter_serviceDesc = grpc.ServiceDesc&#123;</div><div class="line">  ServiceName: <span class="string">"helloworld.Greeter"</span>,</div><div class="line">  HandlerType: (*GreeterServer)(<span class="literal">nil</span>),</div><div class="line">  Methods: []grpc.MethodDesc&#123;</div><div class="line">    &#123;</div><div class="line">      MethodName: <span class="string">"SayHello"</span>, <span class="comment">// 方法名</span></div><div class="line">      Handler:    _Greeter_SayHello_Handler, <span class="comment">// 真正调用SayHello方法的Handler</span></div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">  Streams:  []grpc.StreamDesc&#123;&#125;,</div><div class="line">  Metadata: <span class="string">"examples/helloworld/helloworld/helloworld.proto"</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>grpc.Server</code>的<code>RegisterService</code>方法调用其私有的<code>register</code>方法，最终将服务注册到一个map中保存，以服务描述实例的<code>ServiceName</code>为key， <code>RegisterService</code> 源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterService</span><span class="params">(sd *ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">  ht := reflect.TypeOf(sd.HandlerType).Elem()</div><div class="line">  st := reflect.TypeOf(ss)</div><div class="line">  <span class="keyword">if</span> !st.Implements(ht) &#123;</div><div class="line">    grpclog.Fatalf(<span class="string">"grpc: Server.RegisterService found the handler of type %v that does not satisfy %v"</span>, st, ht)</div><div class="line">  &#125;</div><div class="line">  s.register(sd, ss)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>register</code> 源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">register</span><span class="params">(sd *ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">  s.mu.Lock()</div><div class="line">  <span class="keyword">defer</span> s.mu.Unlock()</div><div class="line">  ...</div><div class="line">  srv := &amp;service&#123;</div><div class="line">    server: ss,</div><div class="line">    md:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*MethodDesc),</div><div class="line">    sd:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*StreamDesc),</div><div class="line">    mdata:  sd.Metadata,</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> sd.Methods &#123;</div><div class="line">    <span class="comment">// 将ServiceDesc中的Methods放入一个map中，以MethodName为key，Methods为value</span></div><div class="line">    d := &amp;sd.Methods[i]</div><div class="line">    srv.md[d.MethodName] = d</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> sd.Streams &#123;</div><div class="line">    <span class="comment">// 将ServiceDesc中的Streams放入一个map中，以StreamName为key，Streams为value</span></div><div class="line">    d := &amp;sd.Streams[i]</div><div class="line">    srv.sd[d.StreamName] = d</div><div class="line">  &#125;</div><div class="line">  s.m[sd.ServiceName] = srv <span class="comment">// 即以"helloworld.Greeter"为key</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-5-服务端请求处理流程"><a href="#2-5-服务端请求处理流程" class="headerlink" title="2.5.服务端请求处理流程"></a>2.5.服务端请求处理流程</h2><p>&emsp;&emsp;从服务端创建代码中可以看到，其绑定GPRC服务到端口，并正式提供服务的核心就是<code>s.Serve(lis)</code>函数，该函数位于<code>google.golang.org/grpc/server.go</code>文件中，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Serve</span><span class="params">(lis net.Listener)</span> <span class="title">error</span></span> &#123;</div><div class="line">  ... <span class="comment">// 预处理操作，比如defer中关闭TCP监听</span></div><div class="line">  <span class="keyword">for</span> &#123;</div><div class="line">    rawConn, err := lis.Accept()</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">      ... <span class="comment">// 一些错误处理等操作</span></div><div class="line">    &#125;</div><div class="line">    s.serveWG.Add(<span class="number">1</span>)</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">      s.handleRawConn(rawConn)</div><div class="line">      s.serveWG.Done()</div><div class="line">    &#125;()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;核心是在一个死循环里，不断<code>Accept</code>新的连接请求，并启动一个新的协程，执行<code>func (s *Server) handleRawConn(rawConn net.Conn)</code>方法，其源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleRawConn</span><span class="params">(rawConn net.Conn)</span></span> &#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">// 完成HTTP2的握手</span></div><div class="line">  st := s.newHTTP2Transport(conn, authInfo)</div><div class="line">	...</div><div class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">    s.serveStreams(st)</div><div class="line">    s.removeConn(st)</div><div class="line">  &#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;核心是对新连接进行处理，启动一个新的协程，执行<code>func (s *Server) serveStreams(st transport.ServerTransport)</code>方法，其源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">serveStreams</span><span class="params">(st transport.ServerTransport)</span></span> &#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">if</span> s.opts.numServerWorkers &gt; <span class="number">0</span> &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">      s.handleStream(st, stream, s.traceInfo(st, stream))</div><div class="line">      wg.Done()</div><div class="line">    &#125;()</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">      <span class="keyword">defer</span> wg.Done()</div><div class="line">      s.handleStream(st, stream, s.traceInfo(st, stream))</div><div class="line">    &#125;()</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;核心是启动一个新的协程，执行<code>func (s *Server) handleStream(...)</code>方法，其源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleStream</span><span class="params">(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo)</span></span> &#123;</div><div class="line">  sm := stream.Method()</div><div class="line">  ...</div><div class="line">  service := sm[:pos]</div><div class="line">  method := sm[pos+<span class="number">1</span>:]</div><div class="line"></div><div class="line">  srv, knownService := s.m[service]</div><div class="line">  <span class="keyword">if</span> knownService &#123;</div><div class="line">    <span class="keyword">if</span> md, ok := srv.md[method]; ok &#123;</div><div class="line">      s.processUnaryRPC(t, stream, srv, md, trInfo)</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> sd, ok := srv.sd[method]; ok &#123;</div><div class="line">      s.processStreamingRPC(t, stream, srv, sd, trInfo)</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;核心是通过RPC请求中指定的 <code>service</code> 和 <code>methond</code> ，从之前保存被注册服务的map中找到对应的服务的方法描述实例，执行 <code>func (s *Server) processUnaryRPC(...) (err error)</code> 方法，其源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">processUnaryRPC</span><span class="params">(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">  <span class="comment">// 解压Request流等预处理</span></div><div class="line">  ...</div><div class="line">  reply, appErr := md.Handler(srv.server, ctx, df, s.opts.unaryInt)</div><div class="line">  <span class="comment">// 发送Response等操作</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;核心是执行 <code>md.Handler(srv.server, ctx, df, s.opts.unaryInt)</code> 方法，这个Handler其实是调用到了 <code>_Greeter_SayHello_Handler</code> ，该函数在一开始的服务描述实例中注册过，最终通过<code>srv.(GreeterServer).SayHello(ctx, in)</code>调用到由我们实现的具体的业务逻辑，其源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Greeter_SayHello_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>, <span class="title">interceptor</span> <span class="title">grpc</span>.<span class="title">UnaryServerInterceptor</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">  in := <span class="built_in">new</span>(HelloRequest)</div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keyword">if</span> interceptor == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="comment">// 最终通过这里调用到由我们实现的具体的业务逻辑</span></div><div class="line">    <span class="keyword">return</span> srv.(GreeterServer).SayHello(ctx, in)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  info := &amp;grpc.UnaryServerInfo&#123;</div><div class="line">    Server:     srv,</div><div class="line">    FullMethod: <span class="string">"/helloworld.Greeter/SayHello"</span>,</div><div class="line">  &#125;</div><div class="line">  handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">    <span class="comment">// 这里应该是一个兜底逻辑</span></div><div class="line">    <span class="keyword">return</span> srv.(GreeterServer).SayHello(ctx, req.(*HelloRequest))</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> interceptor(ctx, in, info, handler)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-6-客户端发送请求流程"><a href="#2-6-客户端发送请求流程" class="headerlink" title="2.6.客户端发送请求流程"></a>2.6.客户端发送请求流程</h2><p>&emsp;&emsp;从客户端的 <code>main.go</code> 可以看到发起请求的流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())</div><div class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">  c := pb.NewSpeakerClient(conn)</div><div class="line"></div><div class="line">  ctx, cancel := context.WithTimeout(context.Background(), time.Second)</div><div class="line">  <span class="keyword">defer</span> cancel()</div><div class="line">  r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: <span class="string">"world"</span>&#125;)</div><div class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  log.Printf(<span class="string">"Speaking: %s, %d"</span>, r.GetMessage(), r.GetCode())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先调用 <code>grpc.Dial(...)</code> 创建一个 <code>ClientConn</code> 类型的连接；再将连接封装到 <code>speakerClient</code> 结构体中的 <code>ClientConnInterface</code> 类型的变量 <code>cc</code>；调用 <code>speakerClient</code> 结构体的 <code>SayHello</code> 方法。<code>SayHello</code> 方法代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *speakerClient)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption)</span> <span class="params">(*HelloReply, error)</span></span> &#123;</div><div class="line">  out := <span class="built_in">new</span>(HelloReply)</div><div class="line">  err := c.cc.Invoke(ctx, <span class="string">"/helloworld.Speaker/SayHello"</span>, in, out, opts...)</div><div class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> out, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里调用到了 <code>ClientConn</code> 的 <code>Invoke</code> 方法，其中调用了私有的 <code>invode</code> 方法。<code>Invoke</code> 方法源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">Invoke</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, args, reply <span class="keyword">interface</span>&#123;&#125;, opts ...CallOption)</span> <span class="title">error</span></span> &#123;</div><div class="line">  <span class="comment">// allow interceptor to see all applicable call options, which means those</span></div><div class="line">  <span class="comment">// configured as defaults from dial option as well as per-call options</span></div><div class="line">  opts = combine(cc.dopts.callOptions, opts)</div><div class="line"></div><div class="line">  <span class="keyword">if</span> cc.dopts.unaryInt != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> cc.dopts.unaryInt(ctx, method, args, reply, cc, invoke, opts...)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> invoke(ctx, method, args, reply, cc, opts...)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Invoke</code> 方法中，新建一个Client流，<code>SendMsg</code> 发送请求，将Request进行预处理后，写入Client的流中；<code>RecvMsg</code> 循环尝试接受Response。<code>SendMsg</code> 和 <code>RecvMsg</code> 源码位于 <code>google.golang.org\grpc\stream.go</code> 文件中，有兴趣可以自行查看。 <code>Invoke</code> 方法源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *ClientConn, opts ...CallOption)</span> <span class="title">error</span></span> &#123;</div><div class="line">  cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...)</div><div class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> err</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> err := cs.SendMsg(req); err != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> err</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cs.RecvMsg(reply)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-6-1-ClientConn与ClientConnInterface的关系"><a href="#2-6-1-ClientConn与ClientConnInterface的关系" class="headerlink" title="2.6.1.ClientConn与ClientConnInterface的关系"></a>2.6.1.ClientConn与ClientConnInterface的关系</h3><p>&emsp;&emsp;<code>google.golang.org\grpc\clientconn.go</code> 定义了一个接口 <code>ClientConnInterface</code>，包含了两个重要的函数，其源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ClientConnInterface <span class="keyword">interface</span> &#123;</div><div class="line">  Invoke(ctx context.Context, method <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;, opts ...CallOption) error</div><div class="line">  NewStream(ctx context.Context, desc *StreamDesc, method <span class="keyword">string</span>, opts ...CallOption) (ClientStream, error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>ClientConn</code> 正是实现了这两个接口，所以在 <code>speakerClient</code> 结构体中，仅包含一个 <code>ClientConnInterface</code> 的变量，上述代码中，传入到 <code>speakerClient</code> 结构体的实际是 <code>ClientConn</code> 类型的变量。</p>
<p>&emsp;&emsp;以上就是官方示例的启动到发送，最后到接受请求的整个流程，学艺不精，如有错误，还请指正。</p>
<h1 id="3-从零开始创建Demo程序"><a href="#3-从零开始创建Demo程序" class="headerlink" title="3.从零开始创建Demo程序"></a>3.从零开始创建Demo程序</h1><p>&emsp;&emsp;不仅要学会看源码是怎么运行的，更要会写自己的代码。所以这里从 <code>.proto</code> 文件开始，创建一个简单的Demo程序。<br>&emsp;&emsp;参考各路大神的文章搭建Goland开发环境，毕竟代码提示和转跳还是比VS CODE好太多了。</p>
<h2 id="3-1-编写并编译proto文件"><a href="#3-1-编写并编译proto文件" class="headerlink" title="3.1.编写并编译proto文件"></a>3.1.编写并编译proto文件</h2><p>&emsp;&emsp;在官方实例的基础上，进行改造，添加了两个字段，并新增了一个RPC方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">syntax = &quot;proto3&quot;;</div><div class="line"></div><div class="line">option go_package = &quot;google.golang.org/grpc/examples/test/model&quot;;</div><div class="line">option java_multiple_files = true;</div><div class="line">option java_package = &quot;io.grpc.examples.test&quot;;</div><div class="line">option java_outer_classname = &quot;HelloWorldProto&quot;;</div><div class="line"></div><div class="line">package helloworld;</div><div class="line"></div><div class="line">service Greeter &#123;</div><div class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</div><div class="line">  rpc SayHi (HelloRequest) returns (HelloReply) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">message HelloRequest &#123;</div><div class="line">  string name = 1;</div><div class="line">  int64 number = 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">message HelloReply &#123;</div><div class="line">  string message = 1;</div><div class="line">  int64 code = 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在 <code>/examples/test</code> 目录下，运行下面的指令，生成 <code>helloworld.pb.go</code> 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc --go_out=plugins=grpc:. --go_opt=paths=source_relative model/helloworld.proto</div></pre></td></tr></table></figure>
<h2 id="3-2-编写Server程序"><a href="#3-2-编写Server程序" class="headerlink" title="3.2.编写Server程序"></a>3.2.编写Server程序</h2><p>&emsp;&emsp;总的来说，还是参考了官方Demo，主要是新增了一个 <code>SayHi</code> 方法，想看看多个方法时，代码的写法是否有所不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</div><div class="line">	log.Printf(<span class="string">"SayHello Func Received: %v, number: %v\n"</span>, in.GetName(), in.GetNumber())</div><div class="line">	<span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">"Hello "</span> + in.GetName()&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHi</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</div><div class="line">	log.Printf(<span class="string">"SayHi Func Received: %v, number: %v\n"</span>, in.GetName(), in.GetNumber())</div><div class="line">	<span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">"Hi "</span> + in.GetName(), Code: <span class="number">200</span>&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-3-编写Client程序"><a href="#3-3-编写Client程序" class="headerlink" title="3.3.编写Client程序"></a>3.3.编写Client程序</h2><p>&emsp;&emsp;同样，Client的代码也参考了官方Demo，主要是新增了一个 <code>SayHi</code> 方法的调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name, Number: number&#125;)</div><div class="line">log.Printf(<span class="string">"Speaking: %s, %d"</span>, r.GetMessage(), r.GetCode())</div><div class="line"></div><div class="line">r, err = c.SayHi(ctx, &amp;pb.HelloRequest&#123;Name: name, Number: number&#125;)</div><div class="line">log.Printf(<span class="string">"Speaking: %s, %d"</span>, r.GetMessage(), r.GetCode())</div></pre></td></tr></table></figure>
<h2 id="3-4-直接通过Goland运行"><a href="#3-4-直接通过Goland运行" class="headerlink" title="3.4.直接通过Goland运行"></a>3.4.直接通过Goland运行</h2><p>&emsp;&emsp;先启动Server，再启动Client，可以看到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Server输出</div><div class="line">2020/06/22 11:44:26 SayHello Func Received: world, number: 1000</div><div class="line">2020/06/22 11:44:26 SayHi Func Received: world, number: 1000</div><div class="line"></div><div class="line"># Client输出</div><div class="line">2020/06/22 11:44:26 Speaking: Hello world, 0</div><div class="line">2020/06/22 11:44:26 Speaking: Hi world, 200</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;其实整个过程跟官方Demo区别不大。最大的不同是官方Demo中的 <code>/examples/helloword/helloword</code> 目录下生成了2个 <code>.go</code> 文件；而我自己测试过程中，编译 <code>.proto</code> 文件后只生成了1个 <code>.go</code> 文件，但其中包含了官方Demo中的所有数据结构、函数，并无本质不同。</p>
<h3 id="3-4-1-Goland执行go-get报SSL-certificate-problem-unable-to-get-local-issuer-certificate错误"><a href="#3-4-1-Goland执行go-get报SSL-certificate-problem-unable-to-get-local-issuer-certificate错误" class="headerlink" title="3.4.1.Goland执行go get报SSL certificate problem: unable to get local issuer certificate错误"></a>3.4.1.Goland执行go get报SSL certificate problem: unable to get local issuer certificate错误</h3><p>&emsp;&emsp;由于这里使用了Goland，和VS Code连接到开发机直接写代码不同，所以需要在Windows上下载项目依赖，执行 <code>go get</code> 报错。原因是证书过期/或者换证书了，解决方案如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 取消对证书的合法性验证</span></div><div class="line">git config --global http.sslverify false</div></pre></td></tr></table></figure>
<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h1><p><a href="https://jiangew.me/grpc-01/" target="_blank" rel="external">gRPC 源码阅读系列 01：gRPC 服务端创建和调用</a>（这是Java版本的gRPC源码解读，有一定的共通性）</p>
<h1 id="5-结语"><a href="#5-结语" class="headerlink" title="5.结语"></a>5.结语</h1><p>　　这是在实习过程中学习到的新知识，且全部是开源数据或者资料，因此分享出来，希望我和大家都有所收获。<br><blockquote><p>参考资料已经在文中列出，这里不再一一列举。</p>
<footer><strong>转载说明</strong></footer></blockquote></p>
<blockquote><p>转载请注明出处，无偿提供。</p>
<footer><strong>@Jiacy</strong><cite><a href="https://jiacyer.com">jiacyer.com</a></cite></footer></blockquote>

    
  </div>
</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">感谢大佬们的支持</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            
              <div name="dashmain" id="dash-main-id-879895" class="dash-main-4 879895-1"></div>
              <script type="text/javascript" charset="utf-8" src="https://www.dashangcloud.com/static/ds-2.0.js"></script>
            
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2020/07/10/mq-kafka-nsq-hippo-basic/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2019/05/25/dockerfile-build-mysql-with-crontab/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>





</div>



  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




<!--<div width="100%" align="center">
<div name="dashmain" id="dash-main-id-879837" class="dash-main-3 879837-1"></div>
<script type="text/javascript" charset="utf-8" src="https://www.dashangcloud.com/static/ds-2.0.js"></script>
</div>
--->


  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              文章
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/project/"
              rel="noopener noreferrer"
              target="_self"
              >
              项目
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              链接
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




    

    

    

<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMTczMy84Mjk3">
 <script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
 </script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->



  </div>

  

  
    <div class="myFooterDiv" style="position:relative; bottom:50px;">
  <footer class="myFooter">
    <p id="footer_text">&copy; 2017 - {$nowYear} ❤ Jiacy  |  Power by Hexo. Built on Github Pages.</p>
  </footer>
</div>

  

</body>
<script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });

    var footer = document.getElementById("footer_text");
    var str = footer.innerHTML;
    var path = window.location.pathname;
    if (path!="/") {
      // 更新非主页的页脚年份
      var today = new Date();
      var nowYear = today.getFullYear();
      if(str.indexOf(nowYear) != -1) {
        // 创建时间与现在同年
        str = "&copy; Since " + nowYear + str.substring(str.indexOf("}") + 1, str.length);
      } else {
        // 创建时间与现在非同年
        str = str.replace("{$nowYear}", nowYear);
      }
    } else {
      // 首页
      str = ""
    }

    // 更新并修改颜色
    footer.innerHTML = str;
    footer.style.color = "#dddddd";
  }



</script>

</html>
